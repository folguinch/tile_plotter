window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "tile_plotter", "modulename": "tile_plotter", "type": "module", "doc": "<h1 id=\"plotter\">Plotter</h1>\n"}, {"fullname": "tile_plotter.axes_props", "modulename": "tile_plotter.axes_props", "type": "module", "doc": "<p>Objects for storing axes properties.</p>\n"}, {"fullname": "tile_plotter.axes_props.AxesProps", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps", "type": "class", "doc": "<p>Store Axes properties.</p>\n"}, {"fullname": "tile_plotter.axes_props.AxesProps.__init__", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    xname: str = 'x',\n    yname: str = 'y',\n    xlim: Union[Tuple[float, float], Tuple[NoneType, float], NoneType] = None,\n    ylim: Union[Tuple[float, float], Tuple[NoneType, float], NoneType] = None,\n    xscale: str = 'linear',\n    yscale: str = 'linear',\n    xunit: Union[str, NoneType] = None,\n    yunit: Union[str, NoneType] = None,\n    xlabel: Union[str, NoneType] = None,\n    ylabel: Union[str, NoneType] = None,\n    label_xpad: float = 0,\n    label_ypad: float = 0,\n    set_xlabel: bool = True,\n    set_ylabel: bool = True,\n    set_xticks: bool = True,\n    set_yticks: bool = True,\n    invertx: bool = False,\n    inverty: bool = False,\n    ticks_color: str = 'k',\n    xticks_fmt: Union[NoneType, str, Callable] = '{:.3f}',\n    yticks_fmt: Union[NoneType, str, Callable] = '{:.3f}',\n    unit_fmt: str = '({})'\n)", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.AxesProps.xname", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.xname", "type": "variable", "doc": "<p>X-axis name.</p>\n", "annotation": ": str", "default_value": " = 'x'"}, {"fullname": "tile_plotter.axes_props.AxesProps.yname", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.yname", "type": "variable", "doc": "<p>Y-axis name.</p>\n", "annotation": ": str", "default_value": " = 'y'"}, {"fullname": "tile_plotter.axes_props.AxesProps.xlim", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.xlim", "type": "variable", "doc": "<p>X-axis limits.</p>\n", "annotation": ": Union[Tuple[float, float], Tuple[NoneType, float], NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.AxesProps.ylim", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.ylim", "type": "variable", "doc": "<p>Y-axis limits.</p>\n", "annotation": ": Union[Tuple[float, float], Tuple[NoneType, float], NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.AxesProps.xscale", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.xscale", "type": "variable", "doc": "<p>X-axis scale (linear or log).</p>\n", "annotation": ": str", "default_value": " = 'linear'"}, {"fullname": "tile_plotter.axes_props.AxesProps.yscale", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.yscale", "type": "variable", "doc": "<p>Y-axis scale (linear or log).</p>\n", "annotation": ": str", "default_value": " = 'linear'"}, {"fullname": "tile_plotter.axes_props.AxesProps.xunit", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.xunit", "type": "variable", "doc": "<p>X-axis unit.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.AxesProps.yunit", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.yunit", "type": "variable", "doc": "<p>Y-axis unit.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.AxesProps.xlabel", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.xlabel", "type": "variable", "doc": "<p>X-axis label.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.AxesProps.ylabel", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.ylabel", "type": "variable", "doc": "<p>Y-axis label.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.AxesProps.label_xpad", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.label_xpad", "type": "variable", "doc": "<p>Padding for the x-axis label.</p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.axes_props.AxesProps.label_ypad", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.label_ypad", "type": "variable", "doc": "<p>Padding for the y-axis label.</p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.axes_props.AxesProps.set_xlabel", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.set_xlabel", "type": "variable", "doc": "<p>Draw x-axis label?</p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "tile_plotter.axes_props.AxesProps.set_ylabel", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.set_ylabel", "type": "variable", "doc": "<p>Draw y-axis label?</p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "tile_plotter.axes_props.AxesProps.set_xticks", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.set_xticks", "type": "variable", "doc": "<p>Draw x-axis tick labels?</p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "tile_plotter.axes_props.AxesProps.set_yticks", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.set_yticks", "type": "variable", "doc": "<p>Draw y-axis tick labels?</p>\n", "annotation": ": bool", "default_value": " = True"}, {"fullname": "tile_plotter.axes_props.AxesProps.invertx", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.invertx", "type": "variable", "doc": "<p>Invert x axis direction?</p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "tile_plotter.axes_props.AxesProps.inverty", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.inverty", "type": "variable", "doc": "<p>Invert y axis direction?</p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "tile_plotter.axes_props.AxesProps.ticks_color", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.ticks_color", "type": "variable", "doc": "<p>Ticks color.</p>\n", "annotation": ": str", "default_value": " = 'k'"}, {"fullname": "tile_plotter.axes_props.AxesProps.xticks_fmt", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.xticks_fmt", "type": "variable", "doc": "<p>Ticks labe format for x-axis.</p>\n", "annotation": ": Union[NoneType, str, Callable]", "default_value": " = '{:.3f}'"}, {"fullname": "tile_plotter.axes_props.AxesProps.yticks_fmt", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.yticks_fmt", "type": "variable", "doc": "<p>Ticks labe format for y-axis.</p>\n", "annotation": ": Union[NoneType, str, Callable]", "default_value": " = '{:.3f}'"}, {"fullname": "tile_plotter.axes_props.AxesProps.unit_fmt", "modulename": "tile_plotter.axes_props", "qualname": "AxesProps.unit_fmt", "type": "variable", "doc": "<p>Format for axes unit label.</p>\n", "annotation": ": str", "default_value": " = '({})'"}, {"fullname": "tile_plotter.axes_props.PhysAxesProps", "modulename": "tile_plotter.axes_props", "qualname": "PhysAxesProps", "type": "class", "doc": "<p>Store Axes properties.</p>\n", "bases": "AxesProps"}, {"fullname": "tile_plotter.axes_props.PhysAxesProps.__init__", "modulename": "tile_plotter.axes_props", "qualname": "PhysAxesProps.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    xname: str = 'x',\n    yname: str = 'y',\n    xlim: Union[NoneType, Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity], Tuple[NoneType, NoneType]] = None,\n    ylim: Union[NoneType, Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity], Tuple[NoneType, NoneType]] = None,\n    xscale: str = 'linear',\n    yscale: str = 'linear',\n    xunit: Union[NoneType, astropy.units.core.Unit] = Unit(dimensionless),\n    yunit: Union[NoneType, astropy.units.core.Unit] = Unit(dimensionless),\n    xlabel: Union[str, NoneType] = None,\n    ylabel: Union[str, NoneType] = None,\n    label_xpad: float = 0,\n    label_ypad: float = 0,\n    set_xlabel: bool = True,\n    set_ylabel: bool = True,\n    set_xticks: bool = True,\n    set_yticks: bool = True,\n    invertx: bool = False,\n    inverty: bool = False,\n    ticks_color: str = 'k',\n    xticks_fmt: Union[NoneType, str, Callable] = '{:.3f}',\n    yticks_fmt: Union[NoneType, str, Callable] = '{:.3f}',\n    unit_fmt: str = '({:latex_inline})'\n)", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysAxesProps.xlim", "modulename": "tile_plotter.axes_props", "qualname": "PhysAxesProps.xlim", "type": "variable", "doc": "<p>X-axis limits.</p>\n", "annotation": ": Union[NoneType, Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity], Tuple[NoneType, NoneType]]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysAxesProps.ylim", "modulename": "tile_plotter.axes_props", "qualname": "PhysAxesProps.ylim", "type": "variable", "doc": "<p>Y-axis limits.</p>\n", "annotation": ": Union[NoneType, Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity], Tuple[NoneType, NoneType]]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysAxesProps.xunit", "modulename": "tile_plotter.axes_props", "qualname": "PhysAxesProps.xunit", "type": "variable", "doc": "<p>X-axis unit.</p>\n", "annotation": ": Union[NoneType, astropy.units.core.Unit]", "default_value": " = Unit(dimensionless)"}, {"fullname": "tile_plotter.axes_props.PhysAxesProps.yunit", "modulename": "tile_plotter.axes_props", "qualname": "PhysAxesProps.yunit", "type": "variable", "doc": "<p>Y-axis unit.</p>\n", "annotation": ": Union[NoneType, astropy.units.core.Unit]", "default_value": " = Unit(dimensionless)"}, {"fullname": "tile_plotter.axes_props.PhysAxesProps.unit_fmt", "modulename": "tile_plotter.axes_props", "qualname": "PhysAxesProps.unit_fmt", "type": "variable", "doc": "<p>Format for axes unit label.</p>\n", "annotation": ": str", "default_value": " = '({:latex_inline})'"}, {"fullname": "tile_plotter.axes_props.VScaleProps", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps", "type": "class", "doc": "<p>Store intensity scale and color bar properties.</p>\n"}, {"fullname": "tile_plotter.axes_props.VScaleProps.__init__", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str = 'Intensity',\n    name_cbar2: Union[str, NoneType] = None,\n    vmin: Union[float, NoneType] = None,\n    vmin_cbar2: Union[float, NoneType] = None,\n    vmax: Union[float, NoneType] = None,\n    vmax_cbar2: Union[float, NoneType] = None,\n    vcenter: Union[float, NoneType] = None,\n    a: float = 1000,\n    stretch: str = 'linear',\n    compute_ticks: bool = False,\n    nticks: int = 5,\n    ticks: Union[Sequence[float], NoneType] = None,\n    ticklabels: Union[Sequence[str], NoneType] = None,\n    tickstretch: Union[str, NoneType] = None,\n    label: Union[str, NoneType] = None,\n    labelpad: float = 0,\n    labelpad_cbar2: float = 0,\n    label_cbar2: Union[str, NoneType] = None,\n    ticks_cbar2: Union[Sequence[float], NoneType] = None,\n    norm_cbar2: Union[~Normalization, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.VScaleProps.name", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.name", "type": "variable", "doc": "<p>Color bar name.</p>\n", "annotation": ": str", "default_value": " = 'Intensity'"}, {"fullname": "tile_plotter.axes_props.VScaleProps.name_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.name_cbar2", "type": "variable", "doc": "<p>Color bar name of second axis.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.vmin", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.vmin", "type": "variable", "doc": "<p>Lower limit of color intensity.</p>\n", "annotation": ": Union[float, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.vmin_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.vmin_cbar2", "type": "variable", "doc": "<p>Lower limit of color intensity of bar second axis.</p>\n", "annotation": ": Union[float, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.vmax", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.vmax", "type": "variable", "doc": "<p>Upper limit of color intensity.</p>\n", "annotation": ": Union[float, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.vmax_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.vmax_cbar2", "type": "variable", "doc": "<p>Upper limit of color intensity of bar second axis.</p>\n", "annotation": ": Union[float, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.vcenter", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.vcenter", "type": "variable", "doc": "<p>Mid value for midnorm stretch.</p>\n", "annotation": ": Union[float, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.a", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.a", "type": "variable", "doc": "<p>Scaling for log stretch.</p>\n", "annotation": ": float", "default_value": " = 1000"}, {"fullname": "tile_plotter.axes_props.VScaleProps.stretch", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.stretch", "type": "variable", "doc": "<p>Stretch of color intensity.</p>\n", "annotation": ": str", "default_value": " = 'linear'"}, {"fullname": "tile_plotter.axes_props.VScaleProps.compute_ticks", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.compute_ticks", "type": "variable", "doc": "<p>Compute the ticks or use default?</p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "tile_plotter.axes_props.VScaleProps.nticks", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.nticks", "type": "variable", "doc": "<p>Number of ticks for auto ticks.</p>\n", "annotation": ": int", "default_value": " = 5"}, {"fullname": "tile_plotter.axes_props.VScaleProps.ticks", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.ticks", "type": "variable", "doc": "<p>Color bar ticks.</p>\n", "annotation": ": Union[Sequence[float], NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.ticklabels", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.ticklabels", "type": "variable", "doc": "<p>Tick labels.</p>\n", "annotation": ": Union[Sequence[str], NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.tickstretch", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.tickstretch", "type": "variable", "doc": "<p>Stretch of the ticks.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.label", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.label", "type": "variable", "doc": "<p>Color bar label.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.labelpad", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.labelpad", "type": "variable", "doc": "<p>Shift the color bar label.</p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.axes_props.VScaleProps.labelpad_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.labelpad_cbar2", "type": "variable", "doc": "<p>Shift the second color bar label.</p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.axes_props.VScaleProps.label_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.label_cbar2", "type": "variable", "doc": "<p>Label of the second axis of the color bar.</p>\n", "annotation": ": Union[str, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.ticks_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.ticks_cbar2", "type": "variable", "doc": "<p>Ticks of the second axis of the color bar.</p>\n", "annotation": ": Union[Sequence[float], NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.norm_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.norm_cbar2", "type": "variable", "doc": "<p>Normalization function of the second axis of the color bar.</p>\n", "annotation": ": Union[~Normalization, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.VScaleProps.get_ticks", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.get_ticks", "type": "function", "doc": "<p>Generate the colorbar ticks.</p>\n", "signature": "(self, generate_cbar2: bool = False) -> Tuple", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.VScaleProps.generate_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.generate_cbar2", "type": "function", "doc": "<p>Generate second colorbar.</p>\n", "signature": "(self, unit_fmt: str = '({:latex_inline})')", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.VScaleProps.get_normalization", "modulename": "tile_plotter.axes_props", "qualname": "VScaleProps.get_normalization", "type": "function", "doc": "<p>Determine the normalization of the color stretch.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>vmin:</strong>  optional; scale minimum.</li>\n<li><strong>vmax:</strong>  optional; scale maximum.</li>\n<li><strong>vcenter:</strong>  optional; <code>midnorm</code> scale center.</li>\n</ul>\n", "signature": "(\n    self,\n    vmin: Union[float, NoneType] = None,\n    vmax: Union[float, NoneType] = None,\n    vcenter: Union[float, NoneType] = None\n) -> ~Colormap", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps", "type": "class", "doc": "<p>Store intensity scale and color bar properties.</p>\n", "bases": "VScaleProps"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.__init__", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    name: str = 'Intensity',\n    name_cbar2: Union[str, NoneType] = None,\n    vmin: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vmin_cbar2: Union[float, NoneType] = None,\n    vmax: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vmax_cbar2: Union[float, NoneType] = None,\n    vcenter: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    a: float = 1000,\n    stretch: str = 'linear',\n    compute_ticks: bool = False,\n    nticks: int = 5,\n    ticks: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    ticklabels: Union[Sequence[str], NoneType] = None,\n    tickstretch: Union[str, NoneType] = None,\n    label: Union[str, NoneType] = None,\n    labelpad: float = 0,\n    labelpad_cbar2: float = 0,\n    label_cbar2: Union[str, NoneType] = None,\n    ticks_cbar2: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    norm_cbar2: Union[~Normalization, NoneType] = None,\n    unit: Union[astropy.units.core.Unit, NoneType] = None,\n    unit_cbar2: Union[astropy.units.core.Unit, NoneType] = None,\n    unit_equiv: Union[Callable, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.unit", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.unit", "type": "variable", "doc": "<p>Intensity axis unit.</p>\n", "annotation": ": Union[astropy.units.core.Unit, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.unit_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.unit_cbar2", "type": "variable", "doc": "<p>Intensity axis unit for second color bar.</p>\n", "annotation": ": Union[astropy.units.core.Unit, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.unit_equiv", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.unit_equiv", "type": "variable", "doc": "<p>Equivalency between units of both color bars.</p>\n", "annotation": ": Union[Callable, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.vmin", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.vmin", "type": "variable", "doc": "<p>Lower limit of colot intensity.</p>\n", "annotation": ": Union[astropy.units.quantity.Quantity, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.vmax", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.vmax", "type": "variable", "doc": "<p>Upper limit of color intensity.</p>\n", "annotation": ": Union[astropy.units.quantity.Quantity, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.vcenter", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.vcenter", "type": "variable", "doc": "<p>Mid value for midnorm stretch.</p>\n", "annotation": ": Union[astropy.units.quantity.Quantity, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.ticks", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.ticks", "type": "variable", "doc": "<p>Color bar ticks.</p>\n", "annotation": ": Union[astropy.units.quantity.Quantity, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.ticks_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.ticks_cbar2", "type": "variable", "doc": "<p>Ticks of the second axis of the color bar.</p>\n", "annotation": ": Union[astropy.units.quantity.Quantity, NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.set_unit", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.set_unit", "type": "function", "doc": "<p>Safe unit setter.</p>\n\n<p>It ensures that set values are all in the same units.</p>\n", "signature": "(self, value: astropy.units.core.Unit) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.get_vlim", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.get_vlim", "type": "function", "doc": "<p>Get limits for the intensity axis.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>axis:</strong>  optional; 1 for the main axis, 2 for second axis.</li>\n</ul>\n", "signature": "(self, axis: int = 1) -> Tuple[float, float]", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.get_normalization", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.get_normalization", "type": "function", "doc": "<p>Determine the normalization of the color stretch.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>vmin:</strong>  optional; scale minimum.</li>\n<li><strong>vmax:</strong>  optional; scale maximum.</li>\n</ul>\n", "signature": "(\n    self,\n    vmin: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vmax: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> ~Colormap", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.get_ticks", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.get_ticks", "type": "function", "doc": "<p>Get the color bar ticks.</p>\n", "signature": "(self, generate_cbar2: bool = False) -> Tuple", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.check_scale_units", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.check_scale_units", "type": "function", "doc": "<p>Check units of the values defining the intensity scale.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.generate_cbar2", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.generate_cbar2", "type": "function", "doc": "<p>Fill the properties of second colorbar.</p>\n", "signature": "(self, unit_fmt: str = '({:latex_inline})')", "funcdef": "def"}, {"fullname": "tile_plotter.axes_props.PhysVScaleProps.generate_cblabel", "modulename": "tile_plotter.axes_props", "qualname": "PhysVScaleProps.generate_cblabel", "type": "function", "doc": "<p>Generate color bar label.</p>\n", "signature": "(self, unit_fmt: str = '({:latex_inline})') -> str", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter", "modulename": "tile_plotter.base_plotter", "type": "module", "doc": "<p>Define the base plotter file for all the plotting tools.</p>\n"}, {"fullname": "tile_plotter.base_plotter.BasePlotter", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter", "type": "class", "doc": "<p>Figure axes collection base class.</p>\n\n<p>Keeps track of the Figure axes, whether they have been initialized or not.</p>\n\n<p>The <code>BasePlotter</code> opens and store the configuration file. The plot geometry\ncan be described in 1 or 2 configurations files:</p>\n\n<ul>\n<li>1 file: share the plot geometry information with the plot data\ninformation in one configuration file.</li>\n<li>2 files: the plot data information file defines a\n<code>geometry_config</code> option with the file name of the geometry information\nfile. In this case, after reading the configuration in the data file, the\nconfiguration is updated with the geometry file, i.e. any value in the\ndefault of the data file may be replaced if it is in the geometry file.</li>\n</ul>\n\n<p>The 2nd option is useful for cases where the same geometry is used to plot\ndifferent data. All the options for geometry configuration are available in\n<code>configs/default.cfg</code>.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>config:</strong>  configuration parser proxy of the current section.</li>\n<li><strong>fig:</strong>  matplotlib figure.</li>\n<li><strong>figsize:</strong>  figure size.</li>\n<li><strong>axes:</strong>  the figure axes.</li>\n</ul>\n", "bases": "toolkit.logger.LoggedObject"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.__init__", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.__init__", "type": "function", "doc": "<p>Create a new base plotter.</p>\n", "signature": "(\n    self,\n    config: Union[pathlib.Path, NoneType] = None,\n    section: str = 'DEFAULT',\n    verbose: str = 'v',\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.loc", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.loc", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.section", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.section", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.shape", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.shape", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.projection", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.projection", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.sharex", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.sharex", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.sharey", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.sharey", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.init_axis", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.init_axis", "type": "function", "doc": "<p>Initialize axis by assigning a plot handler.</p>\n\n<p>If the axis is not initialized, it replaces the axis geometry\n(<code>AxisHandler</code>) with a plot handler.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  axis location.</li>\n<li><strong>handler:</strong>  plot handler to replace the geometry.</li>\n<li><strong>projection:</strong>  optional; update axis projection.</li>\n<li><strong>include_cbar:</strong>  optional; initialize the color bar.</li>\n<li><strong>kwargs:</strong>  additional arguments for the handler.</li>\n</ul>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    handler: ~PlotHandler,\n    projection: Union[str, NoneType] = None,\n    include_cbar: Union[bool, NoneType] = None,\n    **kwargs\n) -> ~PlotHandler", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.plot_all", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.plot_all", "type": "function", "doc": "<p>Iterate over the configuration sections and plot each one.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.apply_config", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.apply_config", "type": "function", "doc": "<p>Apply the configuration of the axis.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.insert_section", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.insert_section", "type": "function", "doc": "<p>Insert a new section to the configuration.</p>\n", "signature": "(self, section: str, value: Dict, switch: bool = False) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.switch_to", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.switch_to", "type": "function", "doc": "<p>Change the current <code>config</code> proxy.</p>\n", "signature": "(self, section: str) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.is_init", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.is_init", "type": "function", "doc": "<p>Check if an axis has been initialized.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  axis location.</li>\n<li><strong>cbaxis:</strong>  whether to check for a colorbar axis instead.</li>\n</ul>\n", "signature": "(self, loc: Tuple[int, int], cbaxis: bool = False) -> bool", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.init_cbar", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.init_cbar", "type": "function", "doc": "<p>Initialize color bar.</p>\n", "signature": "(self, loc: Tuple[int, int]) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.has_cbar", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.has_cbar", "type": "function", "doc": "<p>Shortcut for axes[loc].has_cbar().</p>\n", "signature": "(self, loc: Tuple[int, int]) -> bool", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.has_axlabels", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.has_axlabels", "type": "function", "doc": "<p>Check if axis has label or is shared.</p>\n", "signature": "(self, loc: Tuple[int, int]) -> Tuple[bool, bool]", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.has_ticks_labels", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.has_ticks_labels", "type": "function", "doc": "<p>Check if axis has tick labels.</p>\n", "signature": "(self, loc: Tuple[int, int]) -> Tuple[bool, bool]", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.get_loc_index", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.get_loc_index", "type": "function", "doc": "<p>Get the axis index of the given location.</p>\n", "signature": "(self, loc: Tuple[int, int]) -> int", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.get_value", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.get_value", "type": "function", "doc": "<p>Get value from configuration.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>key:</strong>  option in the configuration parser.</li>\n<li><strong>loc:</strong>  optional; axis location.</li>\n<li><strong>kwargs:</strong>  optional arguments for <code>configparseradv.getvalue</code>.\nSee <code>configparseradv</code> documentation for a list of available kwargs.</li>\n</ul>\n", "signature": "(\n    self,\n    key: str,\n    loc: Union[Tuple[int, int], NoneType] = None,\n    **kwargs\n) -> Any", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.set_title", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.set_title", "type": "function", "doc": "<p>Set figure title.</p>\n", "signature": "(self, title: str, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.base_plotter.BasePlotter.savefig", "modulename": "tile_plotter.base_plotter", "qualname": "BasePlotter.savefig", "type": "function", "doc": "<p>Save figure.</p>\n", "signature": "(self, filename: pathlib.Path, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.common_types", "modulename": "tile_plotter.common_types", "type": "module", "doc": "<p>Commonly used types.</p>\n"}, {"fullname": "tile_plotter.data_loaders", "modulename": "tile_plotter.data_loaders", "type": "module", "doc": "<p>Implement loaders for different types of data.</p>\n"}, {"fullname": "tile_plotter.data_loaders.load_image", "modulename": "tile_plotter.data_loaders", "qualname": "load_image", "type": "function", "doc": "<p>Load FITS file.</p>\n", "signature": "(\n    filename: pathlib.Path\n) -> Tuple[astropy.io.fits.hdu.image.PrimaryHDU, astropy.wcs.wcs.WCS]", "funcdef": "def"}, {"fullname": "tile_plotter.data_loaders.load_pvimage", "modulename": "tile_plotter.data_loaders", "qualname": "load_pvimage", "type": "function", "doc": "<p>Load FITS file.</p>\n", "signature": "(\n    filename: pathlib.Path\n) -> Tuple[astropy.io.fits.hdu.image.PrimaryHDU, str]", "funcdef": "def"}, {"fullname": "tile_plotter.data_loaders.data_loader", "modulename": "tile_plotter.data_loaders", "qualname": "data_loader", "type": "function", "doc": "<p>Find a loader and loads the data from a config parser proxy.</p>\n\n<p>If the <code>loader</code> option is given in the configuration, then this is used to\ndetermine the loader. The value of the <code>loader</code> option specifies option\nwhere the data file name is stored. Otherwise, it will iterate over the\nloaders available and use the one matching the options.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>config:</strong>  config parser proxy.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The loaded data.\n  The projection of the data.\n  The data type.</p>\n</blockquote>\n", "signature": "(\n    config: configparseradv.configparser.ConfigParserAdv,\n    log: Callable = <built-in function print>\n) -> Tuple[~Data, ~Projection, str]", "funcdef": "def"}, {"fullname": "tile_plotter.geometry", "modulename": "tile_plotter.geometry", "type": "module", "doc": "<p>Objects to configure and manage plot geometries.</p>\n"}, {"fullname": "tile_plotter.geometry.BaseGeometry", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry", "type": "class", "doc": "<p>Figure geometry class.</p>\n\n<p>Stores the dimesions and position of an axis.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>xsize:</strong>  x axis size.</li>\n<li><strong>ysize:</strong>  y axis size.</li>\n<li><strong>left:</strong>  left margin.</li>\n<li><strong>right:</strong>  right margin.</li>\n<li><strong>bottom:</strong>  bottom margin.</li>\n<li><strong>top:</strong>  top margin.</li>\n<li><strong>position:</strong>  axis position within figure.</li>\n</ul>\n"}, {"fullname": "tile_plotter.geometry.BaseGeometry.__init__", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    xsize: float,\n    ysize: float,\n    left: float = 0,\n    right: float = 0,\n    top: float = 0,\n    bottom: float = 0,\n    position: Tuple[float, float] = <factory>\n)", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.BaseGeometry.left", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.left", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.BaseGeometry.right", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.right", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.BaseGeometry.top", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.top", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.BaseGeometry.bottom", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.bottom", "type": "variable", "doc": "<p></p>\n", "annotation": ": float", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.BaseGeometry.height", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.height", "type": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "tile_plotter.geometry.BaseGeometry.width", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.width", "type": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "tile_plotter.geometry.BaseGeometry.pyplot_axis", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.pyplot_axis", "type": "variable", "doc": "<p></p>\n", "annotation": ": List[float]"}, {"fullname": "tile_plotter.geometry.BaseGeometry.scale_xaxis", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.scale_xaxis", "type": "function", "doc": "<p>Scale the x axis and keep the axis centered.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>factor:</strong>  scaling factor.</li>\n<li><strong>original:</strong>  optional; original size for recentering. If None then the\ncurrent size is used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Amount of shift applied to the axis in order to center in relation to\n  the other axes in the horizontal direction.</p>\n</blockquote>\n", "signature": "(self, factor: float, original: Union[float, NoneType] = None) -> float", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.BaseGeometry.scale_yaxis", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.scale_yaxis", "type": "function", "doc": "<p>Scale the y axis and keep the axis centered.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>factor:</strong>  scaling factor.</li>\n<li><strong>original:</strong>  optional; original size for recentering. If None then the\ncurrent size is used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Amount of shift applied to the axis in order to center in relation to\n  the other axes in the vertical direction.</p>\n</blockquote>\n", "signature": "(self, factor: float, original: Union[float, NoneType] = None) -> float", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.BaseGeometry.scalex", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.scalex", "type": "function", "doc": "<p>Scale all the horizontal variables by factor.</p>\n", "signature": "(self, factor: float) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.BaseGeometry.scaley", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.scaley", "type": "function", "doc": "<p>Scale all the vertical variables by factor.</p>\n", "signature": "(self, factor: float) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.BaseGeometry.is_empty", "modulename": "tile_plotter.geometry", "qualname": "BaseGeometry.is_empty", "type": "function", "doc": "<p>Is the geometry empty?</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler", "type": "class", "doc": "<p>Stores the axes of a plot.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>axis:</strong>  main axis.</li>\n<li><strong>cbaxis:</strong>  colorbar axis.</li>\n<li><strong>cborientation:</strong>  orientation of the colorbar.</li>\n</ul>\n"}, {"fullname": "tile_plotter.geometry.AxisHandler.__init__", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.__init__", "type": "function", "doc": "<p>Initiate the figure geometry.</p>\n", "signature": "(\n    self,\n    axis: Union[tile_plotter.geometry.BaseGeometry, NoneType] = None,\n    cbaxis: Union[tile_plotter.geometry.BaseGeometry, NoneType] = None,\n    cbar_orientation: Union[str, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.width", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.width", "type": "variable", "doc": "<p>Returns the total width.</p>\n", "annotation": ": float"}, {"fullname": "tile_plotter.geometry.AxisHandler.height", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.height", "type": "variable", "doc": "<p>Return the total height.</p>\n", "annotation": ": float"}, {"fullname": "tile_plotter.geometry.AxisHandler.dimensions", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.dimensions", "type": "variable", "doc": "<p>The total width and height of the geometry.</p>\n", "annotation": ": Tuple[float, float]"}, {"fullname": "tile_plotter.geometry.AxisHandler.handler", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.handler", "type": "variable", "doc": "<p></p>\n", "annotation": ": ~PlotHandler"}, {"fullname": "tile_plotter.geometry.AxisHandler.set_cbar", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.set_cbar", "type": "function", "doc": "<p>Validate color bar value.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>orientation:</strong>  orientation of the color bar.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError:</strong>  if orientation not in [None, vertical, horizontal].</li>\n</ul>\n", "signature": "(self, orientation: Union[NoneType, str]) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.unset_cbar", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.unset_cbar", "type": "function", "doc": "<p>Delete color bar axis.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>sharex:</strong>  optional; is the x-axis shared?</li>\n<li><strong>sharey:</strong>  optional; is the y-axis shared?</li>\n</ul>\n", "signature": "(self, sharex: bool = False, sharey: bool = False) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.has_cbar", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.has_cbar", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.has_vertical_cbar", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.has_vertical_cbar", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.has_horizontal_cbar", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.has_horizontal_cbar", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.set_handler", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.set_handler", "type": "function", "doc": "<p>Set the handler value.</p>\n", "signature": "(self, handler: ~PlotHandler) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.init_geometry", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.init_geometry", "type": "function", "doc": "<p>Initialize axes with a BaseGeometry from input values.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>xsize:</strong>  x axis size.</li>\n<li><strong>ysize:</strong>  y axis size.</li>\n<li><strong>left:</strong>  left margin.</li>\n<li><strong>right:</strong>  right margin.</li>\n<li><strong>top:</strong>  top margin.</li>\n<li><strong>bottom:</strong>  margin.</li>\n<li><strong>cbar_orientation:</strong>  optional; color bar orientation.</li>\n<li><strong>cbar_width:</strong>  optional; color bar width.</li>\n<li><strong>cbar_spacing:</strong>  optional; separation between main axis and color bar.</li>\n<li><strong>position:</strong>  optional; position of the axis.</li>\n</ul>\n", "signature": "(\n    self,\n    xsize: float,\n    ysize: float,\n    left: float,\n    right: float,\n    top: float,\n    bottom: float,\n    cbar_orientation: Union[str, NoneType] = None,\n    cbar_width: Union[float, NoneType] = None,\n    cbar_spacing: Union[float, NoneType] = None,\n    position: Tuple[float, float] = (0.0, 0.0)\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.geometry_from_config", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.geometry_from_config", "type": "function", "doc": "<p>Initialize axes from config file.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>config:</strong>  configuration parser proxy.</li>\n</ul>\n", "signature": "(\n    self,\n    config: <module 'configparseradv' from '/home/users/folguin/python/configparseradv/__init__.py'>\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.set_spacing", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.set_spacing", "type": "function", "doc": "<p>Update geometries for a shared axis.</p>\n\n<p>Left and bottom spacing are not added if the axis in the left or bottom\nmargins, respectively. If axes are shared, then the respective values\nreplace the current <code>left</code> and <code>bottom</code> values, while <code>top</code> and <code>right</code>\nvalues are set to zero if the position is not in the figure top and\nright margins.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>left_spacing:</strong>  optional; space at the left of the axis.</li>\n<li><strong>bottom_spacing:</strong>  optional; space at the bottom of the axis.</li>\n<li><strong>sharex:</strong>  is the x axis shared?</li>\n<li><strong>sharey:</strong>  is the y axis shared?</li>\n<li><strong>is_top:</strong>  is the axis at the topmost row of the figure?</li>\n<li><strong>is_bottom:</strong>  is the axis at the bottom row of the figure?</li>\n<li><strong>is_left:</strong>  is the axis at the leftmost column of the figure?</li>\n<li><strong>is_right:</strong>  is the axis at the rightmost column of the figure?</li>\n</ul>\n", "signature": "(\n    self,\n    left_spacing: float = 0,\n    bottom_spacing: float = 0,\n    sharex: bool = False,\n    sharey: bool = False,\n    is_top: bool = False,\n    is_bottom: bool = False,\n    is_left: bool = False,\n    is_right: bool = False\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.shift_position", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.shift_position", "type": "function", "doc": "<p>Shift the positions of the axes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>xshift:</strong>  shift for the x position.</li>\n<li><strong>yshift:</strong>  shift for the y position.</li>\n</ul>\n", "signature": "(self, xshift: float = 0.0, yshift: float = 0.0) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.AxisHandler.scale_axes", "modulename": "tile_plotter.geometry", "qualname": "AxisHandler.scale_axes", "type": "function", "doc": "<p>Scale the axes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>xfactor:</strong>  x axis scaling factor.</li>\n<li><strong>yfactor:</strong>  y axis scaling factor.</li>\n<li><strong>xoriginal:</strong>  optional; original x axis width for recentering.</li>\n<li><strong>yoriginal:</strong>  optional; original y axis height for recentering.</li>\n</ul>\n", "signature": "(\n    self,\n    xfactor: float = 1.0,\n    yfactor: float = 1.0,\n    xoriginal: Union[float, NoneType] = None,\n    yoriginal: Union[float, NoneType] = None\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.GeometryHandler", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler", "type": "class", "doc": "<p>Manage the geometries in a figure.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>nrows:</strong>  number of rows.</li>\n<li><strong>ncols:</strong>  number of columns.</li>\n<li><strong>sharex:</strong>  are x axes shared?</li>\n<li><strong>sharey:</strong>  are y axes shared?</li>\n<li><strong>vspace:</strong>  vertical spacing between axes.</li>\n<li><strong>hspace:</strong>  horizontal spacing between axes.</li>\n<li><strong>vcbarpos:</strong>  vertical color bar positions.</li>\n<li><strong>hcbarpos:</strong>  horizontal color bar positions.</li>\n</ul>\n", "bases": "toolkit.logger.LoggedObject, collections.OrderedDict"}, {"fullname": "tile_plotter.geometry.GeometryHandler.nrows", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.nrows", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.GeometryHandler.ncols", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.ncols", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.GeometryHandler.sharex", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.sharex", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "tile_plotter.geometry.GeometryHandler.sharey", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.sharey", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "tile_plotter.geometry.GeometryHandler.vspace", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.vspace", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.GeometryHandler.hspace", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.hspace", "type": "variable", "doc": "<p></p>\n", "annotation": ": int", "default_value": " = 0"}, {"fullname": "tile_plotter.geometry.GeometryHandler.vcbarpos", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.vcbarpos", "type": "variable", "doc": "<p></p>\n", "annotation": ": Union[Tuple[int], NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.geometry.GeometryHandler.hcbarpos", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.hcbarpos", "type": "variable", "doc": "<p></p>\n", "annotation": ": Union[Tuple[int], NoneType]", "default_value": " = None"}, {"fullname": "tile_plotter.geometry.GeometryHandler.verbose", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.verbose", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'v'"}, {"fullname": "tile_plotter.geometry.GeometryHandler.keys_from_shape", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.keys_from_shape", "type": "function", "doc": "<p>Fill the handler with an empty geometry.</p>\n", "signature": "(self, rows: int, cols: int) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.GeometryHandler.from_config", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.from_config", "type": "function", "doc": "<p>Initiate spatial values from configuration parser.</p>\n", "signature": "(\n    self,\n    config: <module 'configparseradv' from '/home/users/folguin/python/configparseradv/__init__.py'>\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.GeometryHandler.fill_from_config", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.fill_from_config", "type": "function", "doc": "<p>Fill the dictionary with <code>AxisHandler</code> from configuration parser.</p>\n", "signature": "(self, config: configparseradv.configparser.ConfigParserAdv) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.GeometryHandler.init_loc", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.init_loc", "type": "function", "doc": "<p>Initiate a single <code>AxisHandler</code> at given location from configuration.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  location of the axis.</li>\n<li><strong>config:</strong>  configuration parser proxy.</li>\n<li><strong>xshift:</strong>  optional; shift of the x axis location.</li>\n<li><strong>yshift:</strong>  optional; shift of the y axis location.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The dimensions of the axis.</p>\n</blockquote>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    config: configparseradv.configparser.ConfigParserAdv,\n    xshift: float = 0,\n    yshift: float = 0\n) -> Tuple[float, float]", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.GeometryHandler.set_spacing", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.set_spacing", "type": "function", "doc": "<p>Set the space between axes.</p>\n", "signature": "(self, loc: Tuple[int, int]) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.geometry.GeometryHandler.remove_cbar", "modulename": "tile_plotter.geometry", "qualname": "GeometryHandler.remove_cbar", "type": "function", "doc": "<p>Remove color bar and adjust spacing.</p>\n", "signature": "(self, loc: Tuple[int, int]) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.handlers", "modulename": "tile_plotter.handlers", "type": "module", "doc": "<p>Manage the available plot handlers.</p>\n"}, {"fullname": "tile_plotter.handlers.get_handler", "modulename": "tile_plotter.handlers", "qualname": "get_handler", "type": "function", "doc": "<p>Find a plotting handler based on the <code>config</code> proxy options.</p>\n\n<p>If a <code>handler</code> option is given in the configuration, then this is used to\nobtain the respective handler. Otherwise, it will iterate over the stored\nhandlers and find a key matching the options.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>config:</strong>  a config parser proxy.</li>\n</ul>\n", "signature": "(config: configparser.ConfigParser) -> ~PlotHandler", "funcdef": "def"}, {"fullname": "tile_plotter.logging_tools", "modulename": "tile_plotter.logging_tools", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.logging_tools.get_logger", "modulename": "tile_plotter.logging_tools", "qualname": "get_logger", "type": "function", "doc": "<p>Creates a new logger.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<blockquote>\n  <p>name (str): name of the logger.\n  file_name (str): file name of the log.</p>\n</blockquote>\n\n<h6 id=\"keywords\">Keywords</h6>\n\n<blockquote>\n  <p>filelevel (default=logging.DEBUG): logging to file level.\n  stdoutlevel (default=logging.INFO): logging to std output level.\n  filefmt (str, default=%(asctime)s - %(name)s - %(levelname)s: %(message)s): \n      logging to file message format.\n  stdoutfmt (str, default=%(levelname)s: %(message)s): \n      logging to std output message format.\n  maxBytes (int, default=5MB): maximum size of logging file in bytes.\n  backupCount (int, default=5): maximum number of log files to rotate.</p>\n</blockquote>\n", "signature": "(name, file_name='debug.log', **kwargs)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter", "modulename": "tile_plotter.map_plotter", "type": "module", "doc": "<p>Objects for plotting images.</p>\n"}, {"fullname": "tile_plotter.map_plotter.filter_config_data", "modulename": "tile_plotter.map_plotter", "qualname": "filter_config_data", "type": "function", "doc": "<p>Filter the data options in <code>config</code> present in <code>skeleton</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>config:</strong>  input configuration.</li>\n<li><strong>keys:</strong>  available keys.</li>\n<li><strong>ignore:</strong>  optional; keys to ignore.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dictionary with the filtered values.</p>\n</blockquote>\n", "signature": "(\n    config: configparseradv.configparser.ConfigParserAdv,\n    keys: Sequence,\n    ignore: Sequence = ('image', 'contour')\n) -> Dict", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler", "type": "class", "doc": "<p>Handler for a map single plot.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>im:</strong>  Object from <code>plt.imshow</code>.</li>\n<li><strong>axes_props:</strong>  axes properties.</li>\n<li><strong>vscale:</strong>  intensity scale parameters.</li>\n<li><strong>artists:</strong>  artists to plot.</li>\n<li><strong>radesys:</strong>  projection system.</li>\n<li><strong>skeleton:</strong>  skeleton for the configuration options.</li>\n</ul>\n", "bases": "tile_plotter.plot_handler.PhysPlotHandler"}, {"fullname": "tile_plotter.map_plotter.MapHandler.__init__", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.__init__", "type": "function", "doc": "<p>Initiate a map plot handler.</p>\n", "signature": "(\n    self,\n    axis: ~Axes,\n    cbaxis: Union[~Axes, NoneType] = None,\n    radesys: Union[str, NoneType] = None,\n    axes_props: Union[Mapping, NoneType] = None,\n    vscale: Union[Mapping, NoneType] = None,\n    artists: Union[Mapping, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.skeleton", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.skeleton", "type": "variable", "doc": "<p></p>\n", "default_value": " = <configparseradv.configparser.ConfigParserAdv object>"}, {"fullname": "tile_plotter.map_plotter.MapHandler.from_config", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.from_config", "type": "function", "doc": "<p>Create a new MapHandler from a config proxy.</p>\n\n<p>Default <code>units</code> are taken from the class <code>skeleton</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>config:</strong>  configuration parser proxy.</li>\n<li><strong>axis:</strong>  matplotlib axis.</li>\n<li><strong>cbaxis:</strong>  matplotlib color bar axis.</li>\n<li><strong>radesys:</strong>  optional; projection system.</li>\n<li><strong>kwargs:</strong>  replace values in the config.</li>\n</ul>\n", "signature": "(\n    cls,\n    config: configparseradv.configparser.ConfigParserAdv,\n    axis: ~Axes,\n    cbaxis: ~Axes,\n    radesys: Union[str, NoneType] = None,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.vmin", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.vmin", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.map_plotter.MapHandler.vmax", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.vmax", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.map_plotter.MapHandler.vcenter", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.vcenter", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.map_plotter.MapHandler.stretch", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.stretch", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.map_plotter.MapHandler.get_transform", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.get_transform", "type": "function", "doc": "<p></p>\n", "signature": "(self, value: Union[Any, NoneType] = None)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.plot_map", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.plot_map", "type": "function", "doc": "<p>Plot image data.</p>\n\n<p>The map can be recenter and zoomed using the <code>position</code> and <code>radius</code>\nparameters if the data <code>wcs</code> can be determined or is given.</p>\n\n<p>Contour keywords are used only if <code>self_contours</code> are requested.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data:</strong>  input map.</li>\n<li><strong>wcs:</strong>  optional; WCS object of the map.</li>\n<li><strong>extent:</strong>  optional; <code>xy</code> range of the data (left, right, bottom, top).</li>\n<li><strong>use_extent:</strong>  optional; determine extent from data and ignore wcs.</li>\n<li><strong>rms:</strong>  optional; map noise level.</li>\n<li><strong>mask_bad:</strong>  optional; mask bad/null pixels?</li>\n<li><strong>mask_color:</strong>  optional; color for bad/null pixels.</li>\n<li><strong>position:</strong>  optional; center of the map.</li>\n<li><strong>radius:</strong>  optional; radius of the region shown.</li>\n<li><strong>shift_data:</strong>  optional; an additive constant to apply to the data.</li>\n<li><strong>self_contours:</strong>  optional; plot contours of the data too?</li>\n<li><strong>contour_levels:</strong>  optional; self contour levels.</li>\n<li><strong>contour_colors:</strong>  optional; self contour colors.</li>\n<li><strong>contour_linewidths:</strong>  optional; self contours line width.</li>\n<li><strong>contour_nsigma:</strong>  optional; level of the lowest contour.</li>\n<li><strong>contour_negative_nsigma:</strong>  optional; level of the highest negative\ncontour.</li>\n<li><strong>contour_nsigmalevel:</strong>  optional; plot only one contour at this level\ntimes the rms value.</li>\n<li><strong>contour_colors:</strong>  optional; self contour stretch.</li>\n<li><strong>**kwargs:</strong>  optional; additional arguments for <code>pyplot.imshow</code>.</li>\n</ul>\n", "signature": "(\n    self,\n    data: ~Map,\n    wcs: Union[astropy.wcs.wcs.WCS, NoneType] = None,\n    extent: Union[Tuple[astropy.units.quantity.Quantity], NoneType] = None,\n    use_extent: bool = False,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    mask_bad: bool = False,\n    mask_color: str = 'w',\n    position: Union[astropy.coordinates.sky_coordinate.SkyCoord, NoneType] = None,\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    shift_data: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    self_contours: bool = False,\n    contour_levels: Union[List[astropy.units.quantity.Quantity], NoneType] = None,\n    contour_colors: str = 'w',\n    contour_linewidths: Union[float, NoneType] = None,\n    contour_nsigma: float = 5.0,\n    contour_negative_nsigma: Union[float, NoneType] = None,\n    contour_nsigmalevel: Union[float, NoneType] = None,\n    contour_stretch: Union[str, NoneType] = None,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.plot_contours", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.plot_contours", "type": "function", "doc": "<p>Plot a contour map.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data:</strong>  input map.</li>\n<li><strong>wcs:</strong>  optional; WCS object of the map.</li>\n<li><strong>extent:</strong>  optional; <code>xy</code> range of the data (left, right, bottom, top).</li>\n<li><strong>use_extent:</strong>  optional; determine extent from data and ignore wcs.</li>\n<li><strong>rms:</strong>  optional; map noise level.</li>\n<li><strong>levels:</strong>  optional; contour levels.</li>\n<li><strong>colors:</strong>  optional; contour colors.</li>\n<li><strong>nsigma:</strong>  optional; level of the lowest contour over rms.</li>\n<li><strong>negative_nsigma:</strong>  optional; level of the highest negative contour.</li>\n<li><strong>nsigmalevel:</strong>  optional; plot only one contour at this level times the\nrms value.</li>\n<li><strong>stretch:</strong>  optional; stretch of contour levels (default:\n<code>axes_props.stretch</code>)</li>\n<li><strong>ignore_units:</strong>  optional; ignore data units?</li>\n<li><strong>**kwargs:</strong>  optional; additional arguments for <code>pyplot.contours</code>.</li>\n</ul>\n", "signature": "(\n    self,\n    data: ~Map,\n    wcs: Union[astropy.wcs.wcs.WCS, NoneType] = None,\n    extent: Union[Tuple[astropy.units.quantity.Quantity], NoneType] = None,\n    use_extent: bool = False,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    levels: Union[List[astropy.units.quantity.Quantity], NoneType] = None,\n    colors: Union[Sequence[str], NoneType] = None,\n    nsigma: float = 5.0,\n    negative_nsigma: Union[float, NoneType] = None,\n    nsigmalevel: Union[float, NoneType] = None,\n    stretch: Union[str, NoneType] = None,\n    ignore_units: bool = False,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.plot_artists", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.plot_artists", "type": "function", "doc": "<p>Plot all the stored artists.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.plot_cbar", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.plot_cbar", "type": "function", "doc": "<p>Plot the color bar.</p>\n\n<p>If ticks are not given, they will be determined from the other\nparameters (nticks, vmin, vmax, a, stretch, etc.) or use the defaults\nfrom matplotlib.</p>\n\n<p>When a second (clone) color bar axis is requested, the <code>equivalency</code>\nargument can be used to convert the values of the color bar axis ticks.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>fig:</strong>  figure object.</li>\n<li><strong>orientation:</strong>  orientation of the color bar.</li>\n<li><strong>lines:</strong>  optional; lines from contour plot to overplot.</li>\n</ul>\n", "signature": "(\n    self,\n    fig: matplotlib.figure.Figure,\n    orientation: str,\n    lines: Union[~Plot, NoneType] = None\n) -> Union[matplotlib.colorbar.Colorbar, NoneType]", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.plot_beam", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.plot_beam", "type": "function", "doc": "<p>Plot radio beam.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>header:</strong>  data header to read pixel size and beam.</li>\n<li><strong>beam:</strong>  optional; replaces the values from header.</li>\n<li><strong>color:</strong>  optional; beam color.</li>\n<li><strong>dx:</strong>  optional; x-axis shift.</li>\n<li><strong>dy:</strong>  optional; y-axis shift.</li>\n<li><strong>pad:</strong>  optional; shift for both axes.</li>\n<li><strong>kwargs:</strong>  optional keywords for <code>matplotlib.patches.Ellipse</code>.</li>\n</ul>\n", "signature": "(\n    self,\n    header: Mapping,\n    beam: Union[radio_beam.beam.Beam, NoneType] = None,\n    color: str = 'k',\n    dx: float = 1.0,\n    dy: float = 1.0,\n    pad: float = 2.0,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.recenter", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.recenter", "type": "function", "doc": "<p>Recenter and zoom the plot.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>r:</strong>  radius of the region shown.</li>\n<li><strong>position:</strong>  center of the map.</li>\n<li><strong>wcs:</strong>  WCS object of the map.</li>\n</ul>\n", "signature": "(\n    self,\n    r: astropy.units.quantity.Quantity,\n    position: astropy.coordinates.sky_coordinate.SkyCoord,\n    wcs: astropy.wcs.wcs.WCS\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.config_map", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.config_map", "type": "function", "doc": "<p>Apply configuration to map axes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>set_xlabel:</strong>  optional; display <code>x</code> axis label?</li>\n<li><strong>set_ylabel:</strong>  optional; display <code>y</code> axis label?</li>\n<li><strong>set_xticks:</strong>  optional; display <code>x</code> axis tick labels?</li>\n<li><strong>set_yticks:</strong>  optional; display <code>y</code> axis tick labels?</li>\n<li><strong>xcoord:</strong>  optional; name of the <code>x</code> coordinate axis.</li>\n<li><strong>ycoord:</strong>  optional; name of the <code>y</code> coordinate axis.</li>\n</ul>\n", "signature": "(\n    self,\n    set_xlabel: Union[bool, NoneType] = None,\n    set_ylabel: Union[bool, NoneType] = None,\n    set_xticks: Union[bool, NoneType] = None,\n    set_yticks: Union[bool, NoneType] = None,\n    xcoord: str = 'ra',\n    ycoord: str = 'dec'\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.config_plot", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.config_plot", "type": "function", "doc": "<p>Configure the plot.</p>\n\n<p>Configures several aspects of the axes: limits, scales, labels and\nticks. It overrides and updates some of the default parameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>xticks:</strong>  optional; x ticks values.</li>\n<li><strong>yticks:</strong>  optional; y ticks values.</li>\n<li><strong>minor_xticks:</strong>  optional; minor x ticks values.</li>\n<li><strong>minor_yticks:</strong>  optional; minor y ticks values.</li>\n<li><strong>axes_props:</strong>  optional; any other axes property.</li>\n</ul>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.scatter", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.scatter", "type": "function", "doc": "<p>Scatter plot.</p>\n", "signature": "(\n    self,\n    x: Union[float, astropy.units.quantity.Quantity],\n    y: Union[float, astropy.units.quantity.Quantity],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.text", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.text", "type": "function", "doc": "<p>Scatter plot.</p>\n", "signature": "(\n    self,\n    x: Union[float, astropy.units.quantity.Quantity],\n    y: Union[float, astropy.units.quantity.Quantity],\n    text: str,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.region", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.region", "type": "function", "doc": "<p>Plot a region.</p>\n", "signature": "(\n    self,\n    x: Union[float, astropy.units.quantity.Quantity],\n    y: Union[float, astropy.units.quantity.Quantity],\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.axline", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.axline", "type": "function", "doc": "<p>Plot a line with given slope passing through <code>x, y</code>.</p>\n", "signature": "(\n    self,\n    x: astropy.units.quantity.Quantity,\n    y: astropy.units.quantity.Quantity,\n    slope: astropy.units.quantity.Quantity,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.arrow", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.arrow", "type": "function", "doc": "<p>Draw an arrow.</p>\n\n<h6 id=\"an-arrow-can-be-specified-by-the-following-combiantions\">An arrow can be specified by the following combiantions</h6>\n\n<blockquote>\n  <ul>\n  <li>(PA,)</li>\n  <li>(x, y, PA)</li>\n  <li>(PA, length)</li>\n  <li>(x, y, PA, length)</li>\n  </ul>\n</blockquote>\n\n<p>with PA the position angle (from axis <code>y&gt;0</code> towards axis <code>x&lt;0</code>). The\nkeyword argument <code>xycoords</code> can be used to specify the coordinate\nsystem of the <code>(x, y)</code> position. The default is to use <code>data</code>\ncoordinates. The <code>length</code> is specified in axes fraction.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x, y:</strong>  position of the center of the arrow.</li>\n<li><strong>pa:</strong>  position angle of the arrow.</li>\n<li><strong>length:</strong>  optional; length of the arrow.</li>\n<li><strong>kwargs:</strong>  optional; arrow properties for <code>matplotlib.pyplot.annotate</code>.</li>\n</ul>\n", "signature": "(\n    self,\n    x: Union[astropy.units.quantity.Quantity, float],\n    y: Union[astropy.units.quantity.Quantity, float],\n    pa: astropy.units.quantity.Quantity,\n    length: float = 0.5,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.scale", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.scale", "type": "function", "doc": "<p>Plot physical scale.</p>\n\n<p>Either <code>size</code> or <code>length</code> must be set to determine the size and value\nfor the label of the scale.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>x0, y0:</strong>  position of the origin of the scale.</li>\n<li><strong>distance:</strong>  distance to the source.</li>\n<li><strong>size:</strong>  physical size of the scale.</li>\n<li><strong>length:</strong>  angular length of the scale.</li>\n<li><strong>kwargs:</strong>  additional properties (e.g. <code>color</code>, <code>zorder</code>)</li>\n</ul>\n", "signature": "(\n    self,\n    x0: astropy.units.quantity.Quantity,\n    y0: astropy.units.quantity.Quantity,\n    distance: astropy.units.quantity.Quantity,\n    size: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    length: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    unit: astropy.units.core.Unit = Unit(\"AU\"),\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.auto_plot", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.auto_plot", "type": "function", "doc": "<p>Plot the input data and the stored artists.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data:</strong>  data to plot.</li>\n<li><strong>dtype:</strong>  type of plot.</li>\n<li><strong>config:</strong>  config parser proxy.</li>\n</ul>\n", "signature": "(\n    self,\n    data: ~Map,\n    dtype: str,\n    config: configparseradv.configparser.ConfigParserAdv\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapHandler.brightness_temperature", "modulename": "tile_plotter.map_plotter", "qualname": "MapHandler.brightness_temperature", "type": "function", "doc": "<p>Store brightness temperature equivalency function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>header:</strong>  FITS file header.</li>\n<li><strong>beam:</strong>  optional; beam area.</li>\n</ul>\n", "signature": "(\n    self,\n    header: Mapping,\n    beam: Union[radio_beam.beam.Beam, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapsPlotter", "modulename": "tile_plotter.map_plotter", "qualname": "MapsPlotter", "type": "class", "doc": "<p>Plotter for managing 2-D maps.</p>\n", "bases": "tile_plotter.base_plotter.BasePlotter"}, {"fullname": "tile_plotter.map_plotter.MapsPlotter.projection", "modulename": "tile_plotter.map_plotter", "qualname": "MapsPlotter.projection", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.map_plotter.MapsPlotter.init_axis", "modulename": "tile_plotter.map_plotter", "qualname": "MapsPlotter.init_axis", "type": "function", "doc": "<p>Initialize the axis.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  axis location (row, column).</li>\n<li><strong>projection:</strong>  optional; map projection.</li>\n<li><strong>include_cbar:</strong>  optional; include color bar?</li>\n<li><strong>kwargs:</strong>  additional parameters for <code>MapHandler.from_config</code>.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A <code>MapHandler</code>.</p>\n</blockquote>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    projection: Union[~Projection, NoneType] = None,\n    include_cbar: Union[bool, NoneType] = None,\n    **kwargs\n) -> tile_plotter.map_plotter.MapHandler", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapsPlotter.plot", "modulename": "tile_plotter.map_plotter", "qualname": "MapsPlotter.plot", "type": "function", "doc": "<p>Plot the current configuration section.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>projection:</strong>  optional; map projection.</li>\n</ul>\n", "signature": "(self, projection: ~Projection = None) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.map_plotter.MapsPlotter.plot_loc", "modulename": "tile_plotter.map_plotter", "qualname": "MapsPlotter.plot_loc", "type": "function", "doc": "<p>Plot everythnig at a given location.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  axis location.</li>\n<li><strong>projection:</strong>  optional; map projection.</li>\n</ul>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    projection: Union[~Projection, NoneType] = None\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter", "modulename": "tile_plotter.multi_plotter", "type": "module", "doc": "<p>Manage different types of plots.</p>\n"}, {"fullname": "tile_plotter.multi_plotter.MultiPlotter", "modulename": "tile_plotter.multi_plotter", "qualname": "MultiPlotter", "type": "class", "doc": "<p>Multiple plot manager.</p>\n\n<p>It determines the type of plot for each <code>section</code> of the input\nconfiguration and initiates the appropriate handler.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>config:</strong>  configuration parser proxy of the current section.</li>\n<li><strong>fig:</strong>  matplotlib figure.</li>\n<li><strong>figsize:</strong>  figure size.</li>\n<li><strong>axes:</strong>  the figure axes.</li>\n</ul>\n", "bases": "tile_plotter.base_plotter.BasePlotter"}, {"fullname": "tile_plotter.multi_plotter.MultiPlotter.__init__", "modulename": "tile_plotter.multi_plotter", "qualname": "MultiPlotter.__init__", "type": "function", "doc": "<p>Initialize plotter.</p>\n", "signature": "(\n    self,\n    config: Union[pathlib.Path, NoneType] = None,\n    verbose: str = 'v',\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.MultiPlotter.plot_type", "modulename": "tile_plotter.multi_plotter", "qualname": "MultiPlotter.plot_type", "type": "variable", "doc": "<p>Type of plot.</p>\n"}, {"fullname": "tile_plotter.multi_plotter.MultiPlotter.init_axis", "modulename": "tile_plotter.multi_plotter", "qualname": "MultiPlotter.init_axis", "type": "function", "doc": "<p>Initialize axis by assigning a plot handler.</p>\n\n<p>If the axis is not initialized, it replaces the axis geometry\n(<code>FigGeometry</code>) with a plot handler. The plot handler is determined\nfrom the configuration.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  axis location.</li>\n<li><strong>projection:</strong>  optional; update axis projection.</li>\n<li><strong>include_cbar:</strong>  optional; initialize the color bar.</li>\n<li><strong>kwargs:</strong>  additional arguments for the handler.</li>\n</ul>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    projection: Union[str, NoneType] = None,\n    include_cbar: Union[bool, NoneType] = None,\n    **kwargs\n) -> ~PlotHandler", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.MultiPlotter.plot_all", "modulename": "tile_plotter.multi_plotter", "qualname": "MultiPlotter.plot_all", "type": "function", "doc": "<p>Plot all the sections in config.</p>\n\n<p>Data is loaded based on the plot type.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.MultiPlotter.apply_config", "modulename": "tile_plotter.multi_plotter", "qualname": "MultiPlotter.apply_config", "type": "function", "doc": "<p>Apply the plot configuration.</p>\n", "signature": "(self, loc: Tuple[int, int], handler: ~PlotHandler, dtype: str)", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.MultiPlotter.plot_sections", "modulename": "tile_plotter.multi_plotter", "qualname": "MultiPlotter.plot_sections", "type": "function", "doc": "<p>Plot the requested sections in the requested location.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>sections:</strong>  list of sections to plot.</li>\n<li><strong>loc:</strong>  location where the sections are plotted.</li>\n</ul>\n", "signature": "(self, sections: Sequence, loc: Tuple[int, int])", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.OTFMultiPlotter", "modulename": "tile_plotter.multi_plotter", "qualname": "OTFMultiPlotter", "type": "class", "doc": "<p>On-the-fly multiple plot manager.</p>\n\n<p>It manages multiplotter without needing a configuration file. It\ncan be initialized with the basic properties of the plot that replace the\ndefault values of a tile plot (e.g. properties like the number of rows and\ncolumns).</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>config:</strong>  configuration parser proxy of the current section.</li>\n<li><strong>fig:</strong>  matplotlib figure.</li>\n<li><strong>figsize:</strong>  figure size.</li>\n<li><strong>axes:</strong>  the figure axes.</li>\n</ul>\n", "bases": "tile_plotter.base_plotter.BasePlotter"}, {"fullname": "tile_plotter.multi_plotter.OTFMultiPlotter.__init__", "modulename": "tile_plotter.multi_plotter", "qualname": "OTFMultiPlotter.__init__", "type": "function", "doc": "<p>Initialize plotter.</p>\n", "signature": "(self, **props)", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.OTFMultiPlotter.init_axis", "modulename": "tile_plotter.multi_plotter", "qualname": "OTFMultiPlotter.init_axis", "type": "function", "doc": "<p>Initialize axis by assigning a plot handler.</p>\n\n<p>If the axis is not initialized, it replaces the axis geometry\n(<code>FigGeometry</code>) with a plot handler. The plot handler is determined\nfrom the configuration.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  axis location.</li>\n<li><strong>handler:</strong>  handler name.</li>\n<li><strong>projection:</strong>  optional; update axis projection.</li>\n<li><strong>include_cbar:</strong>  optional; initialize the color bar.</li>\n</ul>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    handler: str,\n    projection: Union[str, NoneType] = None,\n    include_cbar: Union[bool, NoneType] = None\n) -> ~PlotHandler", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.OTFMultiPlotter.gen_handler", "modulename": "tile_plotter.multi_plotter", "qualname": "OTFMultiPlotter.gen_handler", "type": "function", "doc": "<p>Generate a handler with the given properties.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>loc:</strong>  axis location.</li>\n<li><strong>handler:</strong>  handler name.</li>\n<li><strong>projection:</strong>  optional; update axis projection.</li>\n<li><strong>include_cbar:</strong>  optional; initialize the color bar.</li>\n<li><strong>props:</strong>  optional; properties for the handler.</li>\n</ul>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    handler: str,\n    projection: Union[str, NoneType] = None,\n    include_cbar: Union[bool, NoneType] = None,\n    **props\n) -> ~PlotHandler", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.OTFMultiPlotter.plot_all", "modulename": "tile_plotter.multi_plotter", "qualname": "OTFMultiPlotter.plot_all", "type": "function", "doc": "<p>Iterate over the configuration sections and plot each one.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "tile_plotter.multi_plotter.OTFMultiPlotter.apply_config", "modulename": "tile_plotter.multi_plotter", "qualname": "OTFMultiPlotter.apply_config", "type": "function", "doc": "<p>Apply the plot configuration.</p>\n", "signature": "(\n    self,\n    loc: Tuple[int, int],\n    handler: ~PlotHandler,\n    dtype: str,\n    label: str = '',\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "tile_plotter.normalizations", "modulename": "tile_plotter.normalizations", "type": "module", "doc": "<p></p>\n"}, {"fullname": "tile_plotter.normalizations.MidpointNormalize", "modulename": "tile_plotter.normalizations", "qualname": "MidpointNormalize", "type": "class", "doc": "<p>A class which, when called, linearly normalizes data into the\n<code>[0.0, 1.0]</code> interval.</p>\n", "bases": "matplotlib.colors.Normalize"}, {"fullname": "tile_plotter.normalizations.MidpointNormalize.__init__", "modulename": "tile_plotter.normalizations", "qualname": "MidpointNormalize.__init__", "type": "function", "doc": "<h2 id=\"parameters\">Parameters</h2>\n\n<p>vmin, vmax : float or None\n    If <em>vmin</em> and/or <em>vmax</em> is not given, they are initialized from the\n    minimum and maximum value, respectively, of the first input\n    processed; i.e., <code>__call__(A)</code> calls <code>autoscale_None(A)</code>.</p>\n\n<p>clip : bool, default: False\n    If <code>True</code> values falling outside the range <code>[vmin, vmax]</code>,\n    are mapped to 0 or 1, whichever is closer, and masked values are\n    set to 1.  If <code>False</code> masked values remain masked.</p>\n\n<pre><code>Clipping silently defeats the purpose of setting the over, under,\nand masked colors in a colormap, so it is likely to lead to\nsurprises; therefore the default is ``clip=False``.\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Returns 0 if <code>vmin == vmax</code>.</p>\n", "signature": "(self, vmin=None, vmax=None, vcenter=0.0, clip=True)", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler", "modulename": "tile_plotter.plot_handler", "type": "module", "doc": "<p>Objects for handling all type of plots.</p>\n"}, {"fullname": "tile_plotter.plot_handler.PlotHandler", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler", "type": "class", "doc": "<p>Container for axes of a single plot.</p>\n\n<p>Class for easy and quick configuration of a single axes object. This plot\nmay be included in a grid of several plots.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>axis:</strong>  axes of the plot (alias ax).</li>\n<li><strong>cbaxis:</strong>  color bar axes (alias cbax).</li>\n<li><strong>axes_props:</strong>  properties of axes.</li>\n<li><strong>vscale:</strong>  instensity scale and color bar properties.</li>\n<li><strong>pltd:</strong>  plotted objects tracker.</li>\n<li><strong>is_config:</strong>  set to <code>True</code> when configuration has been applied.</li>\n<li><strong>skeleton:</strong>  base configuration.</li>\n</ul>\n"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.__init__", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.__init__", "type": "function", "doc": "<p>Create a single plot container.</p>\n", "signature": "(\n    self,\n    axis: type,\n    cbaxis: Union[type, NoneType] = None,\n    vscale: Union[Mapping, NoneType] = None,\n    **axes_props\n)", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.skeleton", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.skeleton", "type": "variable", "doc": "<p></p>\n", "default_value": " = <configparseradv.configparser.ConfigParserAdv object>"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.ax", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.ax", "type": "variable", "doc": "<p></p>\n", "annotation": ": type"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.cbax", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.cbax", "type": "variable", "doc": "<p></p>\n", "annotation": ": type"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.xlim", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.xlim", "type": "variable", "doc": "<p>Get x axis limits.</p>\n", "annotation": ": Tuple[float, float]"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.ylim", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.ylim", "type": "variable", "doc": "<p>Get y axis limits.</p>\n", "annotation": ": Tuple[float, float]"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.insert_plt", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.insert_plt", "type": "function", "doc": "<p>Store plotted object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>key:</strong>  label of the plotted object.</li>\n<li><strong>val:</strong>  plotted object.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The plotted object in val.</p>\n</blockquote>\n", "signature": "(self, key: str, val: ~Plot) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.config_plot", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.config_plot", "type": "function", "doc": "<p>Configure the plot.</p>\n\n<p>Configures several aspects of the axes: limits, scales, labels and\nticks. It overrides and updates some of the default parameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>xticks:</strong>  optional; x ticks values.</li>\n<li><strong>yticks:</strong>  optional; y ticks values.</li>\n<li><strong>minor_xticks:</strong>  optional; minor x ticks values.</li>\n<li><strong>minor_yticks:</strong>  optional; minor y ticks values.</li>\n<li><strong>axes_props:</strong>  optional; any other axes property.</li>\n</ul>\n", "signature": "(\n    self,\n    xticks: List[float] = None,\n    yticks: List[float] = None,\n    minor_xticks: List[float] = None,\n    minor_yticks: List[float] = None,\n    **axes_props\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.set_axlabels", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.set_axlabels", "type": "function", "doc": "<p>Set the axis labels.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>xlabel:</strong>  optional; x axis label.</li>\n<li><strong>ylabel:</strong>  optional; y axis label.</li>\n</ul>\n", "signature": "(\n    self,\n    xlabel: Union[str, NoneType] = None,\n    ylabel: Union[str, NoneType] = None\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.plot", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.plot", "type": "function", "doc": "<p>Plot on the axis.</p>\n\n<p>Arguments are the same as for the <code>matplotlib.pyplot.plot</code> function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  data to plot.</li>\n<li><strong>kwargs:</strong>  arguments for <code>matplotlib.pyplot.plot</code>.</li>\n</ul>\n", "signature": "(self, *args, **kwargs) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.axhline", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.axhline", "type": "function", "doc": "<p>Plot horizontal line.</p>\n\n<p>Arguments are the same as for the <code>matplotlib.pyplot.axhline</code> function.</p>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.axvline", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.axvline", "type": "function", "doc": "<p>Plot vertical line.</p>\n\n<p>Arguments are the same as for the <code>matplotlib.pyplot.axvline</code> function.</p>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.axline", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.axline", "type": "function", "doc": "<p>Plot a line from position and slope.</p>\n\n<p>Arguments are the same as for the <code>matplotlib.pyplot.axline</code> function.</p>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.axvspan", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.axvspan", "type": "function", "doc": "<p>Axis vertical span.</p>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.axhspan", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.axhspan", "type": "function", "doc": "<p>Axis horizontal span.</p>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.errorbar", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.errorbar", "type": "function", "doc": "<p>Plot on the axis.</p>\n\n<p>Arguments are the same as for the <code>matplotlib.pyplot.errorbar</code> function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  data to plot.</li>\n<li><strong>kwargs:</strong>  arguments for <code>matplotlib.pyplot.errorbar</code>.</li>\n</ul>\n", "signature": "(self, *args, **kwargs) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.title", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.title", "type": "function", "doc": "<p>Set plot title.</p>\n", "signature": "(self, text: str, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.annotate", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.annotate", "type": "function", "doc": "<p>Annotate the axis.</p>\n\n<p>Arguments are the same as for the <code>matplotlib.pyplot.annotate</code> function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  data to plot.</li>\n<li><strong>kwargs:</strong>  arguments for <code>matplotlib.pyplot.annotate</code>.</li>\n</ul>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.legend", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.legend", "type": "function", "doc": "<p>Plot the legend.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>handlers:</strong>  matplotlib plot handlers.</li>\n<li><strong>labels:</strong>  labels for each handler.</li>\n<li><strong>loc:</strong>  legend position. See <code>matplotlib.pyplot.lengend</code> documentation\nfor available values and positions (default 0, i.e. best location).</li>\n<li><strong>auto:</strong>  use stored handlers.</li>\n<li><strong>match_colors:</strong>  match legend artist and legend text colors.</li>\n</ul>\n", "signature": "(\n    self,\n    handlers: Union[~Plot, NoneType] = None,\n    labels: Union[List[str], NoneType] = None,\n    loc: int = 0,\n    auto: bool = False,\n    match_colors: bool = False,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.scatter", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.scatter", "type": "function", "doc": "<p>Scatter plot.</p>\n", "signature": "(self, *args, **kwargs) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.text", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.text", "type": "function", "doc": "<p>Scatter plot.</p>\n", "signature": "(self, *args, **kwargs) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.clabel", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.clabel", "type": "function", "doc": "<p>Contour labels.</p>\n", "signature": "(self, *args, **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.contour", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.contour", "type": "function", "doc": "<p>Contour map.</p>\n", "signature": "(self, *args, **kwargs) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.tricontour", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.tricontour", "type": "function", "doc": "<p>Triangulation contour map.</p>\n", "signature": "(self, x, y, *args, **kwargs) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.plot_cbar", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.plot_cbar", "type": "function", "doc": "<p>Plot color bar.</p>\n\n<p>If ticks are not given, they will be determined from the other\nparameters (nticks, vmin, vmax, a, stretch, etc.) or use the defaults\nfrom matplotlib.</p>\n\n<p>When a second (clone) color bar axis is requested, the stored\n<code>equivalency</code> can be used to convert the values of the color bar axis\nticks.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>fig:</strong>  figure object.</li>\n<li><strong>cs:</strong>  color map.</li>\n<li><strong>orientation:</strong>  color bar orientation.</li>\n<li><strong>lines:</strong>  optional; lines from contour plot to overplot.</li>\n<li><strong>compute_ticks:</strong>  optional; compute ticks or use default?</li>\n<li><strong>cbar_props:</strong>  optional; additional color bar properties.</li>\n</ul>\n", "signature": "(\n    self,\n    fig: matplotlib.figure.Figure,\n    cs: matplotlib.colors.Colormap,\n    orientation: str,\n    lines: Union[~Plot, NoneType] = None,\n    compute_ticks: Union[bool, NoneType] = None,\n    **cbar_props\n) -> Union[matplotlib.colorbar.Colorbar, NoneType]", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.arrow", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.arrow", "type": "function", "doc": "<p>Draw an arrow.</p>\n\n<h6 id=\"an-arrow-can-be-specified-by-the-following-combiantions\">An arrow can be specified by the following combiantions</h6>\n\n<blockquote>\n  <ul>\n  <li>(PA,)</li>\n  <li>(x, y, PA)</li>\n  <li>(PA, length)</li>\n  <li>(x, y, PA, length)</li>\n  </ul>\n</blockquote>\n\n<p>with PA the position angle (from axis y>0 towards axis x&lt;0). The\npositions (x, y) are in axes fraction and their default value is\n(0.5, 0.5). Similarly, the default legth is 0.5, i.e. half the axis\nlength.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>arrow:</strong>  arrow position, angle and/or legth.</li>\n<li><strong>arrowprops:</strong>  optional; arrow properties.</li>\n<li><strong>color:</strong>  optional; use the default arrowprops but replace the color.</li>\n<li><strong>kwargs:</strong>  other arrow properties. See <code>matplotlib.pyplot.annotate</code>.</li>\n</ul>\n", "signature": "(\n    self,\n    arrow: Union[str, Tuple[float]],\n    arrowprops: Union[dict, NoneType] = None,\n    color: Union[str, NoneType] = None,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.arc", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.arc", "type": "function", "doc": "<p>Draw an arc.</p>\n", "signature": "(self, *args, **kwargs)", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PlotHandler.label_axes", "modulename": "tile_plotter.plot_handler", "qualname": "PlotHandler.label_axes", "type": "function", "doc": "<p>Add a label for the axes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>text:</strong>  label text.</li>\n<li><strong>loc:</strong>  label location.</li>\n<li><strong>**kwargs:</strong>  additional options for the annotate functions.</li>\n</ul>\n", "signature": "(self, text: str, loc: Sequence[float] = (0.1, 0.9), **kwargs) -> None", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PhysPlotHandler", "modulename": "tile_plotter.plot_handler", "qualname": "PhysPlotHandler", "type": "class", "doc": "<p>Plot handler to manage plots with astropy.quantity objects.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>axis:</strong>  axes of the plot (alias ax).</li>\n<li><strong>cbaxis:</strong>  color bar axes (alias cbax).</li>\n<li><strong>axes_props:</strong>  properties of axes.</li>\n<li><strong>vscale:</strong>  instensity scale and color bar properties.</li>\n<li><strong>pltd:</strong>  plotted objects tracker.</li>\n<li><strong>skeleton:</strong>  base configuration.</li>\n</ul>\n", "bases": "PlotHandler"}, {"fullname": "tile_plotter.plot_handler.PhysPlotHandler.__init__", "modulename": "tile_plotter.plot_handler", "qualname": "PhysPlotHandler.__init__", "type": "function", "doc": "<p>Create a single plot container.</p>\n", "signature": "(\n    self,\n    axis: type,\n    cbaxis: Union[type, NoneType] = None,\n    vscale: Union[Mapping, NoneType] = None,\n    **axes_props\n)", "funcdef": "def"}, {"fullname": "tile_plotter.plot_handler.PhysPlotHandler.plot", "modulename": "tile_plotter.plot_handler", "qualname": "PhysPlotHandler.plot", "type": "function", "doc": "<p>Plot on the axis.</p>\n\n<p>Arguments are the same as for the <code>matplotlib.pyplot.plot</code> function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  data to plot.</li>\n<li><strong>kwargs:</strong>  arguments for <code>matplotlib.pyplot.plot</code>.</li>\n</ul>\n", "signature": "(self, *args, **kwargs) -> ~Plot", "funcdef": "def"}, {"fullname": "tile_plotter.plotter", "modulename": "tile_plotter.plotter", "type": "module", "doc": "<p>Data plotting program.</p>\n\n<p>Implements the tile plotting tools to plot data from the command line.</p>\n"}, {"fullname": "tile_plotter.plotter.multiplot", "modulename": "tile_plotter.plotter", "qualname": "multiplot", "type": "function", "doc": "<p></p>\n", "signature": "(args)", "funcdef": "def"}, {"fullname": "tile_plotter.plotter.plotter", "modulename": "tile_plotter.plotter", "qualname": "plotter", "type": "function", "doc": "<p>Main program.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  list of command line inputs.</li>\n</ul>\n", "signature": "(args: Sequence)", "funcdef": "def"}, {"fullname": "tile_plotter.utils", "modulename": "tile_plotter.utils", "type": "module", "doc": "<p>Plotting utilities.</p>\n"}, {"fullname": "tile_plotter.utils.LikeSkyCoord", "modulename": "tile_plotter.utils", "qualname": "LikeSkyCoord", "type": "class", "doc": "<p>Class to emulate a <code>SkyCoord</code> object.</p>\n"}, {"fullname": "tile_plotter.utils.LikeSkyCoord.__init__", "modulename": "tile_plotter.utils", "qualname": "LikeSkyCoord.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    ra: astropy.units.quantity.Quantity,\n    dec: astropy.units.quantity.Quantity\n)", "funcdef": "def"}, {"fullname": "tile_plotter.utils.quick_rms", "modulename": "tile_plotter.utils", "qualname": "quick_rms", "type": "function", "doc": "<p>Estimate the rms of the data using the MAD.</p>\n", "signature": "(\n    data: Union[astropy.units.quantity.Quantity, float, Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]]\n) -> Union[astropy.units.quantity.Quantity, float, Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]]", "funcdef": "def"}, {"fullname": "tile_plotter.utils.to_sigfig", "modulename": "tile_plotter.utils", "qualname": "to_sigfig", "type": "function", "doc": "<p>Round value to sigfig significant figures.</p>\n", "signature": "(\n    x: Union[astropy.units.quantity.Quantity, float, Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]],\n    sigfig: int = 2\n) -> Union[astropy.units.quantity.Quantity, float, Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]]", "funcdef": "def"}, {"fullname": "tile_plotter.utils.get_data_type", "modulename": "tile_plotter.utils", "qualname": "get_data_type", "type": "function", "doc": "<p>Determine the data type based on <code>data</code> unit.</p>\n", "signature": "(\n    data: Union[astropy.units.quantity.Quantity, float, Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]],\n    default: Union[str, NoneType] = None\n) -> str", "funcdef": "def"}, {"fullname": "tile_plotter.utils.get_extent", "modulename": "tile_plotter.utils", "qualname": "get_extent", "type": "function", "doc": "<p>Determine the data extent.</p>\n", "signature": "(\n    data: ~Map,\n    wcs: Union[astropy.wcs.wcs.WCS, NoneType] = None\n) -> List[astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "tile_plotter.utils.get_colorbar_ticks", "modulename": "tile_plotter.utils", "qualname": "get_colorbar_ticks", "type": "function", "doc": "<p>Calculate the tick values for the colorbar given the intensity stretch.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>vmin:</strong>  the minimum of the stretch.</li>\n<li><strong>vmax:</strong>  the maximum of the stretch.</li>\n<li><strong>a:</strong>  optional; scaling for logarithmic stretch.</li>\n<li><strong>n:</strong>  optional; number of ticks.</li>\n<li><strong>stretch:</strong>  optional; stretch type.</li>\n<li><strong>ndigits:</strong>  optional; value of digits for rounding.</li>\n<li><strong>sigfig:</strong>  optional; number of significant figures.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A numpy array quantity with the ticks.</p>\n</blockquote>\n", "signature": "(\n    vmin: astropy.units.quantity.Quantity,\n    vmax: astropy.units.quantity.Quantity,\n    a: float = 1000.0,\n    n: int = 5,\n    stretch: str = 'linear',\n    ndigits: Union[int, NoneType] = None,\n    sigfig: Union[int, NoneType] = None\n) -> Union[astropy.units.quantity.Quantity, float, Union[int, float, complex, str, bytes, numpy.generic, Sequence[Union[int, float, complex, str, bytes, numpy.generic]], Sequence[Sequence[Any]], numpy._array_like._SupportsArray]]", "funcdef": "def"}, {"fullname": "tile_plotter.utils.auto_vmin", "modulename": "tile_plotter.utils", "qualname": "auto_vmin", "type": "function", "doc": "<p>Determine vmin from the data.</p>\n\n<p>The <code>data_type</code> is assumed to be <code>intensity</code> unless specified or if the\nunits of <code>data</code> are equivalent to <code>km/s</code>, in which case it is set to\n<code>velocity</code>. If <code>data_type=intensity</code>, it calculates the rms from the data\nif not given. The value of <code>vmin</code> is <code>rms * nrms</code> in this case. If\n<code>data_type=velocity</code>, <code>vmin</code> is a fraction of the minimum value of the data.</p>\n\n<p>If <code>velocity_fraction</code> is <code>None</code>, the default behaviour is to subtract 2% of\nthe minumum value.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data:</strong>  data to calculate vmin from.</li>\n<li><strong>rms:</strong>  optional; rms of the data.</li>\n<li><strong>nrms:</strong>  optional; number of rms values for vmin.</li>\n<li><strong>velocity_fraction:</strong>  optional; fraction of the minimum value of the data to\nuse if <code>data_type=velocity</code>.</li>\n<li><strong>data_type:</strong>  optional; type of map.</li>\n<li><strong>sigfig:</strong>  optional; number of significant figures of output.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "(\n    data: astropy.units.quantity.Quantity,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    nrms: float = 0.8,\n    velocity_fraction: Union[float, NoneType] = None,\n    data_type: Union[str, NoneType] = None,\n    sigfig: Union[int, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "tile_plotter.utils.auto_vmax", "modulename": "tile_plotter.utils", "qualname": "auto_vmax", "type": "function", "doc": "<p>Determine vmax from the data maximum.</p>\n\n<p>If maximum is given, then this value is used instead of the data. At the\nmoment there isn't any difference based on the map type.</p>\n\n<p>The default behaviour if <code>fraction</code> is <code>None</code> is to add 2% of the maximum\nvalue.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data:</strong>  data to calculate vmax from.</li>\n<li><strong>maximum:</strong>  optional; maximum value.</li>\n<li><strong>fraction:</strong>  optional; fraction of the maximum for vmax.</li>\n<li><strong>sigfig:</strong>  optional; number of significant figures of output.</li>\n</ul>\n", "signature": "(\n    data: astropy.units.quantity.Quantity,\n    maximum: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    fraction: Union[float, NoneType] = None,\n    sigfig: Union[int, NoneType] = None\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "tile_plotter.utils.auto_vminmax", "modulename": "tile_plotter.utils", "qualname": "auto_vminmax", "type": "function", "doc": "<p>Calculate vmin and vmax from data.</p>\n", "signature": "(\n    data: astropy.units.quantity.Quantity,\n    data_type: str = 'intensity',\n    **kwargs\n) -> Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "tile_plotter.utils.get_nlevels", "modulename": "tile_plotter.utils", "qualname": "get_nlevels", "type": "function", "doc": "<p>Determine the number of levels based on the stretch.</p>\n\n<p>Levels are assumed to be a multiple of min_val.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>max_val:</strong>  maximum value.</li>\n<li><strong>min_val:</strong>  minimum value.</li>\n<li><strong>stretch:</strong>  level stretch.</li>\n<li><strong>base:</strong>  optional; base of the log levels.</li>\n</ul>\n", "signature": "(\n    max_val: astropy.units.quantity.Quantity,\n    min_val: astropy.units.quantity.Quantity,\n    stretch: str,\n    base: Union[float, NoneType] = 2.0\n) -> int", "funcdef": "def"}, {"fullname": "tile_plotter.utils.auto_levels", "modulename": "tile_plotter.utils", "qualname": "auto_levels", "type": "function", "doc": "<p>Determine the levels for contour plots.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data:</strong>  optional; data to extract the levels from.</li>\n<li><strong>rms:</strong>  optional; rms of the data.</li>\n<li><strong>max_val:</strong>  optional; maximum contour.</li>\n<li><strong>min_val:</strong>  optional; minumum contour.</li>\n<li><strong>nsigma:</strong>  optional; minimum contour over rms value.</li>\n<li><strong>stretch:</strong>  optional; stretch of the contours.</li>\n<li><strong>negative_nsigma:</strong>  optional; maximum contour for negative levels.</li>\n<li><strong>base:</strong>  optional; logarithmic base.</li>\n<li><strong>nlevels:</strong>  optional; number of levels.</li>\n<li><strong>min_nlevels:</strong>  optional; minimum number of levels.</li>\n<li><strong>min_base:</strong>  optional; minimum base for refining.</li>\n<li><strong>nsigmalevel:</strong>  optional; only one level at this nsigma value.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "(\n    data: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    max_val: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    min_val: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    nsigma: float = 5.0,\n    stretch: str = 'linear',\n    base: float = 2.0,\n    nlevels: Union[int, NoneType] = None,\n    min_nlevels: int = 1,\n    negative_nsigma: Union[float, NoneType] = None,\n    min_base: float = 1.1,\n    nsigmalevel: Optional = None,\n    log: Callable = <built-in function print>\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "tile_plotter.utils.generate_label", "modulename": "tile_plotter.utils", "qualname": "generate_label", "type": "function", "doc": "<p>Generate a standard label from the input values.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name:</strong>  name in the label.</li>\n<li><strong>unit:</strong>  optional; unit in the label.</li>\n<li><strong>unit_fmt:</strong>  optional; format of the unit string.</li>\n</ul>\n", "signature": "(\n    name: str,\n    unit: Union[astropy.units.core.Unit, NoneType] = None,\n    unit_fmt: str = '({})'\n) -> str", "funcdef": "def"}, {"fullname": "tile_plotter.utils.positions_from_region", "modulename": "tile_plotter.utils", "qualname": "positions_from_region", "type": "function", "doc": "<p>Read positions from region file.</p>\n", "signature": "(regions: str, separator: str = ',') -> List", "funcdef": "def"}, {"fullname": "tile_plotter.utils.get_artist_positions", "modulename": "tile_plotter.utils", "qualname": "get_artist_positions", "type": "function", "doc": "<p>Extract the position values for the input <code>artist</code>.</p>\n\n<p>It uses <code>artist</code> to determine the type of the output.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>values:</strong>  string where the positions are obtained.</li>\n<li><strong>artist:</strong>  artist type.</li>\n<li><strong>separator:</strong>  optional; separator between values.</li>\n<li><strong>xycoords:</strong>  optional; type of coordinates.</li>\n<li><strong>phys_frame:</strong>  optional; physical frame of the data (<code>sky</code> or <code>projection</code>)</li>\n</ul>\n", "signature": "(\n    values: str,\n    artist: str,\n    separator: str = ',',\n    xycoords: str = 'data',\n    phys_frame: str = 'sky'\n) -> tuple", "funcdef": "def"}, {"fullname": "tile_plotter.utils.get_artist_properties", "modulename": "tile_plotter.utils", "qualname": "get_artist_properties", "type": "function", "doc": "<p>Extract the properties of the artists from <code>config</code>.</p>\n\n<p>This function creates a dictionary that contain the markers positions as\nkeys and a dictionary of the artist properties as its value. The keywords\nare extracted from the option name in the <code>config</code>.</p>\n\n<p>Example:\nA configuration file with the following options:</p>\n\n<pre><code>scatter = pos1x pos1y, pos2x pos2y\nscatter_color = r, w\n</code></pre>\n\n<p>will be converted to:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"n\">properties</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;positions&#39;</span><span class=\"p\">:</span> <span class=\"p\">((</span><span class=\"n\">pos1x</span><span class=\"p\">,</span> <span class=\"n\">pos1y</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">pos2x</span><span class=\"p\">,</span> <span class=\"n\">pos2y</span><span class=\"p\">)),</span>\n              <span class=\"s1\">&#39;properties&#39;</span><span class=\"p\">:</span> <span class=\"p\">({</span><span class=\"s1\">&#39;color&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;r&#39;</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">&#39;color&#39;</span><span class=\"p\">:</span> <span class=\"s1\">&#39;w&#39;</span><span class=\"p\">})}</span>\n</code></pre></div>\n\n<p>Each dictionary can be used as keyword input for the corresponding\n<code>matplotlib</code> function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>artist:</strong>  name of the artist.</li>\n<li><strong>config:</strong>  configuration parser proxy.</li>\n<li><strong>separator:</strong>  optional; separator between values of an config option.</li>\n<li><strong>float_props:</strong>  optional; list of properties to be converted to float.</li>\n<li><strong>quantity_props:</strong>  optional; list of properties that are <code>Quantity</code>.</li>\n<li><strong>from_region:</strong>  optional; read positions from region?</li>\n</ul>\n", "signature": "(\n    artist: str,\n    config: configparseradv.configparser.ConfigParserAdv,\n    separator: str = ',',\n    float_props: Sequence[str] = ('size', 'width', 'height', 'angle', 's', 'alpha', 'length', 'linewidth'),\n    quantity_props: Sequence[str] = ('pa', 'slope'),\n    from_region: bool = False\n) -> dict", "funcdef": "def"}, {"fullname": "tile_plotter.utils.tick_formatter", "modulename": "tile_plotter.utils", "qualname": "tick_formatter", "type": "function", "doc": "<p>Creates a tick formatter function based on <code>stretch</code>.</p>\n\n<p>The <code>sci</code> parameters determine the decades between where floats are used\ninstead of scientific notation</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>stretch:</strong>  axis scale type.</li>\n<li><strong>sci:</strong>  optional; scientific notation limits</li>\n</ul>\n", "signature": "(stretch: str, sci: Tuple[int, int] = (-3, 4)) -> Callable", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();